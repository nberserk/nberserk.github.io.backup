---
layout: post
title: segment tree
tags: algorithm tree segment
published: true
---

<p>
트리. 트리는 알고리즘 계에서 혁신적인 발견의 하나인데, O(N)으로 걸릴 만한 것을 O(longN)으로 바꿔주는 마법 같은 data structure이다. 트리는 여러가지 쓰임새가 있지만 이중에서도 segment tree에 대해서 알아보자.
</p>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">when</h2>
<div class="outline-text-2" id="text-orgheadline1">
<p>
N개의 배열에서 특정 range(start, end)의 구간합을 구한다고 생각해보자. naive로 하면 O(N)이 걸린다.
각 배열의 값이 변하지 않는다고 가정하면 O(1)으로 값을 구할 수 있다. psum[N]을 선언하고 0~n까지의 합을 미리 계산하여 캐쉬하고 있으면 psum[end] - psum[start]로 구간합을 바로 구할 수 있다.
만약 각 배열의 값이 변한다면 가장 효율적인 방법은 무엇일까.. 이때 segement tree로 값을 구할 수 있다. tree에서의 insert는 O(longN)이므로 segment tree를 생성할때는 O(NlogN)이 걸리고 query는 O(longN), update는 O(longN)이 걸린다.
</p>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2">idea</h2>
<div class="outline-text-2" id="text-orgheadline2">
<p>
heap이랑 구조가 비슷하다. root는 모든 범위의 합을 가지고 있고(0 to N-1), left node는 왼쪽 반, right node는 오른쪽 반을 가지게 계속 나누어서 트리를 구성하면 된다. 각 노드는 자신의 범위를 가지고 그 범위의 구간합을 계산하여 가진다. left와 right의 값이 같아질때까지 이것을 반복하면 segment tree가 완성되게 된다. 
예를 들어, 4개의 원소가 있는 구간트리는 아래처럼 구성 되게 된다. 
</p>
<div class="org-src-container">

<pre class="src src-c++">                  +--------+
                  | (0,3)  |
                  +--------+
      +--------+              +--------+
      |  (0,1) |              |  (2,3) |
      +--------+              +--------+
+--------+  +--------+   +--------+  +--------+
|  (0,0) |  |  (1,1) |   |   (2,2)|  |  (3,3) |
+--------+  +--------+   +--------+  +--------+
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3">implementation</h2>
<div class="outline-text-2" id="text-orgheadline3">
<p>
기본적으로 [start, end] 구간의 중간을 잡아서 왼쪽,오른쪽을 계속 recursive하게 수행하면 된다. 종료 조건은 start와 end가 같을때이다. 그리고 left child의 인덱스는 2*i+1이 되고, 오른쪽 차일드의 인덱스는 2*i+2가 된다. 
그리고 트리의 길이는 원 배열 길이의 4배 정도를 잡아주면 된다. 
</p>
</div>
<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4">build</h3>
<div class="outline-text-3" id="text-orgheadline4">
<p>
위 전제조건으로 구현해 보면 아래처럼 포현할 수 있다. 
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #99968b;">/**</span>
<span style="color: #99968b;"> a: input array</span>
<span style="color: #99968b;">tree: segment tree</span>
<span style="color: #99968b;"> i: index of segment tree  </span>
<span style="color: #99968b;"> */</span> 
<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">build</span>(<span style="color: #92a65e; font-weight: bold;">int</span>* <span style="color: #cae682;">a</span>, <span style="color: #92a65e; font-weight: bold;">int</span>* <span style="color: #cae682;">tree</span>, <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">start</span>, <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">end</span>, <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">i</span>){
    <span style="color: #8ac6f2; font-weight: bold;">if</span> (start==end){
        tree[i] = a[start];
        <span style="color: #8ac6f2; font-weight: bold;">return</span> tree[i];
    }

    <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">m</span> = (end-start)/2;
    tree[i] = build(a,tree, start, m, 2*i+1) +
        build(a, tree, m+1, end, 2*i+2);
    <span style="color: #8ac6f2; font-weight: bold;">return</span> tree[i];
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5">query</h3>
<div class="outline-text-3" id="text-orgheadline5">
<p>
세그먼트 트리를 만들었으니 이제 임의의 범위를 주면 그 합을 리턴해주는 query함수를 만들어 보자.
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #99968b;">// </span><span style="color: #99968b;">start,end : start/end index of tree</span>
<span style="color: #99968b;">// </span><span style="color: #99968b;">qs, qe : query start/end index</span>
<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">query</span>(<span style="color: #92a65e; font-weight: bold;">int</span>*<span style="color: #cae682;">st</span>, <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">qs</span>, <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">qe</span>, <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">start</span>, <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">end</span>, <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">i</span>){
    <span style="color: #99968b;">// </span><span style="color: #99968b;">&#44396;&#44036;&#51012; &#48279;&#50612;&#45224;</span>
    <span style="color: #8ac6f2; font-weight: bold;">if</span> (qe&lt;start || qs&gt;start){
        <span style="color: #8ac6f2; font-weight: bold;">return</span> 0;
    }
    <span style="color: #99968b;">// </span><span style="color: #99968b;">&#53244;&#47532;&#44032; &#48276;&#50948; &#50504;&#50640; &#51080;&#51020;</span>
    <span style="color: #8ac6f2; font-weight: bold;">if</span> (qs&lt;=start &amp;&amp; end&lt;=qe){
        <span style="color: #8ac6f2; font-weight: bold;">return</span> st[i];
    }

    <span style="color: #99968b;">// </span><span style="color: #99968b;">&#44152;&#52432; &#51080;&#45716; &#44221;&#50864;</span>
    <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">m</span> = (end-start)/2;
    <span style="color: #8ac6f2; font-weight: bold;">return</span> query(st,qs,qe,start, m, 2*i+1) + query(st, qs, qe, m+1,end,2*i+2);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6">update</h3>
<div class="outline-text-3" id="text-orgheadline6">
<p>
원 배열의 값이 바뀔때 트리를 업데이트 해주는 함수. 해당 배열이 포함된 모든 노드의 값을 수정해 준다. O(logN)
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">update</span>(<span style="color: #92a65e; font-weight: bold;">int</span>*<span style="color: #cae682;">st</span>, <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">dest</span>, <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">orgValue</span>, <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">newValue</span>){
    update2(st, dest, newValue-orgValue, 0, N-1, i);
}

<span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">update2</span>(<span style="color: #92a65e; font-weight: bold;">int</span>*<span style="color: #cae682;">st</span>, <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">dest</span>, <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">diff</span>, <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">s</span>,<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">e</span>, <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">i</span>){
    <span style="color: #8ac6f2; font-weight: bold;">if</span> (dest&lt;s || dest&gt;e) <span style="color: #8ac6f2; font-weight: bold;">return</span>;

    st[i] += diff;
    <span style="color: #8ac6f2; font-weight: bold;">if</span> (s==e){    
        <span style="color: #8ac6f2; font-weight: bold;">return</span>;
    }
    <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">m</span> = (e-s)/2;
    update2(st, dest, diff, s, m, 2*i+1);
    update2(st, dest, diff, m+1, e, 2*i+2);    
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgheadline7" class="outline-2">
<h2 id="orgheadline7">revision history</h2>
<div class="outline-text-2" id="text-orgheadline7">
<ul class="org-ul">
<li>2015/11/16 initial draft</li>
</ul>
</div>
</div>
